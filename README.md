# AVL

Баланс AVL-дерева

AVL-дерево — это самобалансирующееся бинарное дерево поиска, где для каждого узла высота его левого и правого поддеревьев различается не более чем на 1. Это свойство называется балансом. 
Балансировка

Балансировка — это процесс поддержания баланса дерева при вставке или удалении узлов. В AVL-дереве балансировка достигается с помощью поворотов. Существует четыре основных типа поворотов:

    Правый поворот (Right Rotation):
        Применяется, когда левое поддерево узла становится слишком высоким.
        Узел XX становится правым потомком своего левого потомка YY, а YY становится новым корнем поддерева.

    Левый поворот (Left Rotation):
        Применяется, когда правое поддерево узла становится слишком высоким.
        Узел XX становится левым потомком своего правого потомка YY, а YY становится новым корнем поддерева.

    Лево-правый поворот (Left-Right Rotation):
        Применяется, когда левое поддерево правого потомка узла становится слишком высоким.
        Сначала выполняется левый поворот для правого потомка, затем правый поворот для самого узла.

    Право-левый поворот (Right-Left Rotation):
        Применяется, когда правое поддерево левого потомка узла становится слишком высоким.
        Сначала выполняется правый поворот для левого потомка, затем левый поворот для самого узла.






![изображение](https://github.com/user-attachments/assets/8f981b45-e8ee-4b07-9252-4124b1be0786)

Инициализация:

    Начальная вершина: 1
    Расстояния до всех вершин:
        d[1] = 0
        d[2] = ∞
        d[3] = ∞
        d[4] = ∞
        d[5] = ∞
        d[6] = ∞
    Очередь: [(0, 1)]

Итерация 1:

    Извлекаем вершину с минимальным расстоянием: (0, 1)
    Рассматриваем соседние вершины:
        Вершина 2: d[2] = d[1] + вес(1, 2) = 0 + 1 = 1
    Обновляем очередь: [(1, 2)]

Итерация 2:

    Извлекаем вершину с минимальным расстоянием: (1, 2)
    Рассматриваем соседние вершины:
        Вершина 3: d[3] = d[2] + вес(2, 3) = 1 + 3 = 4
        Вершина 1 (уже обработана)
    Обновляем очередь: [(4, 3)]

Итерация 3:

    Извлекаем вершину с минимальным расстоянием: (4, 3)
    Рассматриваем соседние вершины:
        Вершина 4: d[4] = d[3] + вес(3, 4) = 4 + 1 = 5
        Вершина 5: d[5] = d[3] + вес(3, 5) = 4 + 6 = 10
        Вершина 6: d[6] = d[3] + вес(3, 6) = 4 + 7 = 11
        Вершина 2 (уже обработана)
    Обновляем очередь: [(5, 4), (10, 5), (11, 6)]

Итерация 4:

    Извлекаем вершину с минимальным расстоянием: (5, 4)
    Рассматриваем соседние вершины:
        Вершина 3 (уже обработана)
    Очередь приоритетов остаётся без изменений: [(10, 5), (11, 6)]

Итерация 5:


    Извлекаем вершину с минимальным расстоянием: (10, 5)
    Рассматриваем соседние вершины:
        Вершина 3 (уже обработана)
        Вершина 6: d[6] = d[5] + вес(5, 6) = 10 + 1 = 11
    Очередь приоритетов остаётся без изменений: [(11, 6)]


Итерация 6:

    Извлекаем вершину с минимальным расстоянием: (11, 6)
    Рассматриваем соседние вершины:
        Вершина 3 (уже обработана)
    Очередь приоритетов пуста.

Результат:

Кратчайшие расстояния от вершины 1 до всех остальных вершин:

    d[1] = 0
    d[2] = 1
    d[3] = 4
    d[4] = 5
    d[5] = 10
    d[6] = 11

